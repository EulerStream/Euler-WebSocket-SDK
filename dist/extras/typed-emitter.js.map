{"version":3,"file":"typed-emitter.js","sourceRoot":"","sources":["../../src/extras/typed-emitter.ts"],"names":[],"mappings":";;;;;;AACA,kEAAyC;AAMzC,wEAAwE;AACxE,MAAa,mBAAoB,SAAQ,uBAA6B;CACrE;AADD,kDACC;AAED,SAAS,QAAQ,CAAC,IAAS;IACzB,OAAO,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAChE,CAAC;AAED,SAAS,aAAa,CAAC,IAAS;IAC9B,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,sBAAsB,CAAC;AACzE,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAS;IAClC,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAClC,CAAC;AAED;;;;;GAKG;AACH,SAAgB,UAAU,CAAC,EAAO;IAChC,MAAM,OAAO,GAAG,IAAI,mBAAmB,EAAE,CAAC;IAE1C,EAAE,CAAC,SAAS,GAAG,CAAC,KAAU,EAAE,EAAE;QAC5B,IAAI,IAAY,CAAC;QAEjB,IAAI,OAAO,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;YAClC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;SACnB;aAAM,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;YAC/B,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;SAC9B;aAAM,IAAI,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;YACpC,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC7C;aAAM,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;YACxC,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAqB,CAAC,CAAC;SACnE;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;SACpD;QAED,MAAM,MAAM,GAAwB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACrD,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAW,EAAE,CAAC,CAAC,IAAW,CAAC,CAAC,CAAC;IAC7E,CAAC,CAAC;IAEF,OAAO,OAAO,CAAC;AACjB,CAAC;AAvBD,gCAuBC","sourcesContent":["import {WebcastEventName, WebcastMessageMap} from \"@/webcast\";\nimport EventEmitter from \"eventemitter3\";\nimport {ClientMessageBundle} from \"@/client\";\n\n/** An event-map type for the typed-emitter **/\ntype WebcastEventMap = { [K in WebcastEventName]: (event: WebcastMessageMap[K]) => void; }\n\n/** Cross-compatible Node + Browser event emitter for Webcast events **/\nexport class WebcastEventEmitter extends EventEmitter<WebcastEventMap> {\n}\n\nfunction isBuffer(data: any): data is Buffer {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(data);\n}\n\nfunction isArrayBuffer(data: any): data is ArrayBuffer {\n  return Object.prototype.toString.call(data) === '[object ArrayBuffer]';\n}\n\nfunction isArrayBufferView(data: any): data is ArrayBufferView {\n  return ArrayBuffer.isView(data);\n}\n\n/**\n * Pipes WebSocket messages to a typed event emitter.\n * ASSUMPTION: WebSocket messages are not raw, and not bundled.\n *\n * @param ws The WebSocket instance to pipe events from.\n */\nexport function pipeEvents(ws: any): WebcastEventEmitter {\n  const emitter = new WebcastEventEmitter();\n\n  ws.onmessage = (event: any) => {\n    let data: string;\n\n    if (typeof event.data === 'string') {\n      data = event.data;\n    } else if (isBuffer(event.data)) {\n      data = event.data.toString();\n    } else if (isArrayBuffer(event.data)) {\n      data = new TextDecoder().decode(event.data);\n    } else if (isArrayBufferView(event.data)) {\n      data = new TextDecoder().decode(event.data.buffer as ArrayBuffer);\n    } else {\n      throw new Error('Unsupported message data format');\n    }\n\n    const bundle: ClientMessageBundle = JSON.parse(data);\n    bundle.messages.forEach((m) => emitter.emit(m.type as any, m.data as any));\n  };\n\n  return emitter;\n}\n"]}