{"version":3,"file":"deserialize.js","sourceRoot":"","sources":["../../src/webcast/deserialize.ts"],"names":[],"mappings":";;;AACA,yEAM4C;AAC5C,+CAAgE;AAyEhE,MAAa,kBAAmB,SAAQ,KAAK;IAC3C,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,oBAAoB,CAAC;IACnC,CAAC;CACF;AALD,gDAKC;AAGD;;;;;GAKG;AACH,SAAS,kCAAkC,CACvC,WAAuB,EACvB,kBAAiC;IAGnC,yDAAyD;IACzD,MAAM,uBAAuB,GAAG,wBAAc,CAAC,uBAAa,CAAC,EAAE,CAAC;SAC3D,8BAA8B;SAC9B,MAAM,CAAC,WAAW,CAAC,CAAC;IAEzB,MAAM,cAAc,GAAG,wBAAc,CAAC,kBAAkB,CAAC,CAAC;IAE1D,KAAK,MAAM,OAAO,IAAI,uBAAuB,CAAC,QAAQ,IAAI,EAAE,EAAE;QAE5D,oCAAoC;QACpC,IAAI,CAAC,cAAc,CAAC,GAAG,OAAO,CAAC,IAAI,SAAS,CAAC,EAAE;YAC7C,SAAS;SACV;QAED,0BAA0B;QAC1B,IAAI;YACF,MAAM,WAAW,GAAG,OAAO,CAAC,IAA0B,CAAC;YACvD,MAAM,mBAAmB,GAA0C,kBAAkB,CAAC,WAAiC,EAAE,OAAO,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;YAC9J,OAAO,CAAC,WAAW,GAAG,EAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,mBAAmB,EAAgB,CAAA;SACpF;QAAC,OAAO,EAAE,EAAE;YACX,OAAO,CAAC,IAAI,CAAC,kCAAkC,OAAO,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC;SACpE;KAEF;IAED,OAAO,uBAAuB,CAAC;AACjC,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,kBAAkB,CAC9B,SAAY,EACZ,WAAuB,EACvB,YAA2B;IAG7B,8EAA8E;IAC9E,IAAI,SAAS,KAAK,yBAAyB,EAAE;QAC3C,OAAO,kCAAkC,CAAC,WAAW,EAAE,YAAY,CAAyB,CAAA;KAC7F;IAED,uBAAuB;IACvB,MAAM,WAAW,GAAuB,GAAG,SAAS,SAAS,CAAC;IAC9D,MAAM,SAAS,GAAqC,wBAAc,CAAC,YAAY,CAAC,CAAC,WAAW,CAAC,CAAC;IAE9F,IAAI,CAAC,SAAS,EAAE;QACd,MAAM,IAAI,kBAAkB,CAAC,wBAAwB,SAAS,qCAAqC,CAAC,CAAC;KACtG;IAED,OAAO,SAAS,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AACvC,CAAC;AApBD,gDAoBC;AAOD;;;;;GAKG;AACH,SAAgB,2BAA2B,CAAC,WAAuB,EAAE,kBAAiC;IAEpG,uEAAuE;IACvE,iEAAiE;IACjE,MAAM,0BAA0B,GAAG,0CAAuB,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,iBAAiB;IACjG,IAAI,uBAAuB,GAAwC,SAAS,CAAC;IAE7E,IAAI,0BAA0B,CAAC,IAAI,KAAK,KAAK,EAAE;QAC7C,uBAAuB,GAAG,kBAAkB,CACxC,yBAAyB,EACzB,0BAA0B,CAAC,MAAM,EACjC,kBAAkB,CACrB,CAAC;KACH;IAED,OAAO;QACL,GAAG,0BAA0B;QAC7B,uBAAuB;KACxB,CAAC;AAEJ,CAAC;AApBD,kEAoBC","sourcesContent":["import * as tiktokSchema from \"@/webcast/schemas/tiktok-schema-v2\";\nimport {\n  CommonMessageData,\n  MessageFns,\n  ProtoMessageFetchResult,\n  WebcastPushFrame,\n  WebcastPushFrameDecoder\n} from \"@/webcast/schemas/tiktok-schema-v2\";\nimport {SchemaVersion, WebcastSchemas} from \"@/webcast/schemas\";\n\n/** FUNCTION: Extract type T from MessageFns<T> **/\ntype ExtractType<T> = T extends MessageFns<infer U> ? U : never;\n\n/** FUNCTION: Strips the 'Decoder' suffix from a string **/\ntype StripDecoderSuffix<T> = T extends `${infer Name}Decoder` ? Name : never;\n\n/** FUNCTION: Extract only those message types that have a 'common' property **/\ntype FilterMessagesWithCommon<T> = { [K in keyof T]: T[K] extends { common: CommonMessageData } ? K : never }[keyof T];\n\n/** MAP: Property names in tiktokSchema file to types **/\ntype TikTokSchema = typeof tiktokSchema;\n\n/** MAP: Property names to T from ExtractType<T>. Includes 'nevers' that need to be filtered out  **/\ntype RawExtractedTypes = {\n  [K in keyof TikTokSchema]: ExtractType<TikTokSchema[K]>;\n};\n\n/** UNION: All keys in RawExtractedTypes that DON'T result in a \"never\" **/\ntype FilteredKeys = {\n  [K in keyof RawExtractedTypes]:\n  RawExtractedTypes[K] extends never ? never : K;\n}[keyof RawExtractedTypes];\n\n/** MAP: Names of decoders to the type T they decode **/\nexport type WebcastDecoderMap = { [K in FilteredKeys]: RawExtractedTypes[K]; };\n\n/** UNION: All decoder values (i.e. the Protobuf Message interfaces they decode into) **/\nexport type WebcastMessage = WebcastDecoderMap[keyof WebcastDecoderMap];\n\n/** UNION: All decoder names **/\nexport type WebcastDecoderName = keyof WebcastDecoderMap;\n\n/** MAP: Names of T to the type T **/\nexport type WebcastMessageMap = { [K in keyof WebcastDecoderMap as StripDecoderSuffix<K>]: WebcastDecoderMap[K] };\n\n/** UNION: All type names T **/\nexport type WebcastMessageName = keyof WebcastMessageMap;\n\n/** MAP: Only those messages with a 'common' property **/\nexport type WebcastEventMap = { [K in FilterMessagesWithCommon<WebcastMessageMap>]: WebcastMessageMap[K] };\n\n/** UNION: Names of ONLY Event messages (i.e. Top-Level messages) **/\nexport type WebcastEventName = keyof WebcastEventMap;\n\n/** UNION: Values of ONLY Event messages **/\nexport type WebcastEvent = WebcastEventMap[keyof WebcastEventMap];\n\nexport type RoomInfoEvent = {\n  type: 'roomInfo',\n  data: Record<string, any>\n}\n\nexport type WorkerInfoEvent = {\n  type: 'workerInfo',\n  data: {\n    webSocketId: string;\n    agentId: string;\n    schemaVersion: SchemaVersion;\n  }\n}\n\nexport type CustomData = RoomInfoEvent | WorkerInfoEvent;\n\n/** UNION: All possible pairs of type to the data the type represents **/\nexport type DecodedData = {\n  [K in WebcastMessageName]: {\n    type: K;\n    data: WebcastMessageMap[K]\n  }\n}[WebcastMessageName] | CustomData;\n\nexport class NoSchemaFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NoSchemaFoundError\";\n  }\n}\n\n\n/**\n * Deserialize ProtoMessageFetchResult and all nested messages\n *\n * @param protoBinary Binary\n * @param protoSchemaVersion Version to use when deserializing nested messages\n */\nfunction deserializeProtoMessageFetchResult(\n    protoBinary: Uint8Array,\n    protoSchemaVersion: SchemaVersion\n): ProtoMessageFetchResult {\n\n  // Always pull from Schema V2 for ProtoMessageFetchResult\n  const protoMessageFetchResult = WebcastSchemas[SchemaVersion.v2]\n      .ProtoMessageFetchResultDecoder\n      .decode(protoBinary);\n\n  const selectedSchema = WebcastSchemas[protoSchemaVersion];\n\n  for (const message of protoMessageFetchResult.messages || []) {\n\n    // Skip it if it's not in the schema\n    if (!selectedSchema[`${message.type}Decoder`]) {\n      continue;\n    }\n\n    // Deserialize the message\n    try {\n      const messageType = message.type as WebcastMessageName;\n      const deserializedMessage: WebcastMessageMap[typeof messageType] = deserializeMessage(messageType as WebcastMessageName, message.payload, protoSchemaVersion);\n      message.decodedData = {type: messageType, data: deserializedMessage} as DecodedData\n    } catch (ex) {\n      console.info(`Failed to decode message type: ${message.type}`, ex);\n    }\n\n  }\n\n  return protoMessageFetchResult;\n}\n\n/**\n * Deserialize any message\n *\n * @param protoName Name of the proto to deserialize\n * @param protoBinary Binary for the deserialized proto\n * @param protoVersion Version of the proto schema to use\n */\nexport function deserializeMessage<T extends WebcastMessageName>(\n    protoName: T,\n    protoBinary: Uint8Array,\n    protoVersion: SchemaVersion\n): WebcastMessageMap[T] {\n\n  // These have nested message binaries in them, so we have a custom decoder ^.^\n  if (protoName === \"ProtoMessageFetchResult\") {\n    return deserializeProtoMessageFetchResult(protoBinary, protoVersion) as WebcastMessageMap[T]\n  }\n\n  // Get the decoder name\n  const decoderName: WebcastDecoderName = `${protoName}Decoder`;\n  const decoderFn: MessageFns<WebcastMessageMap[T]> = WebcastSchemas[protoVersion][decoderName];\n\n  if (!decoderFn) {\n    throw new NoSchemaFoundError(`Invalid schema name: ${protoName}, not found in the Protobuf schema.`);\n  }\n\n  return decoderFn.decode(protoBinary);\n}\n\n\nexport type DecodedWebcastPushFrame = WebcastPushFrame & {\n  protoMessageFetchResult?: ProtoMessageFetchResult;\n}\n\n/**\n * Deserialize a WebSocket message into a DecodedWebcastPushFrame\n *\n * @param protoBinary Binary message received from the WebSocket\n * @param protoSchemaVersion Version of the schema to use when deserializing nested messages\n */\nexport function deserializeWebSocketMessage(protoBinary: Uint8Array, protoSchemaVersion: SchemaVersion): DecodedWebcastPushFrame {\n\n  // Websocket messages are in a container which contains additional data\n  // Message type 'msg' represents a normal ProtoMessageFetchResult\n  const rawWebcastWebSocketMessage = WebcastPushFrameDecoder.decode(protoBinary); // Always with v2\n  let protoMessageFetchResult: ProtoMessageFetchResult | undefined = undefined;\n\n  if (rawWebcastWebSocketMessage.type === 'msg') {\n    protoMessageFetchResult = deserializeMessage(\n        \"ProtoMessageFetchResult\",\n        rawWebcastWebSocketMessage.binary,\n        protoSchemaVersion\n    );\n  }\n\n  return {\n    ...rawWebcastWebSocketMessage,\n    protoMessageFetchResult\n  };\n\n}\n"]}